#!/usr/bin/env python3
"""Tool to perform simple Python doc string tests."""

##############################################################################
# Module information.
__author__     = "Dave Pearson"
__copyright__  = "Copyright 2018-2019, Dave Pearson"
__licence__    = "GPL"
__credits__    = [ "Dave Pearson" ]
__maintainer__ = "Dave Pearson"
__email__      = "davep@davep.org"
__version__    = "1.1.0"

##############################################################################
# Imports.
import os
import ast
import argparse
from   pathlib import Path

##############################################################################
# Get all of the doc-able nodes in the given module.
def module_docable_parts( module ):
    """Get nodes that can have doc strings.

    :param Module module: The module to pull nodes from.
    :yields: An item whose doc string should be checked.
    """
    for node in module:
        for item in ast.walk( node ):
            if isinstance( item, ( ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef ) ):
                yield item

##############################################################################
# Get the line count of a doc string.
def line_count( doc_string ):
    """Get the line count of a doc string.

    :param str doc_string: The doc string to get the line count for.
    :returns: The number of lines found in the doc string.
    :rtype: int
    """
    return len( doc_string.splitlines() )

##############################################################################
# Check the doc string of the given node
def check_doc_string( module, node ):
    """Check the doc string of the given node.

    :param PosixPath module: The path of the module we're checking.
    :param AST node: The ast node to check.
    """

    # Work out what name to show.
    try:
        name = node.name
    except AttributeError:
        name = module.name

    # Work out the line number.
    try:
        lineno = node.lineno
    except AttributeError:
        lineno = 0

    # Extract the doc string for the given node.
    doc_string = ast.get_docstring( node, clean=False )

    def short( module ):
        """Get a short name for the path that makes sense."""
        try:
            return module.relative_to( Path().cwd() )
        except ValueError:
            return str( module )

    def report( error ):
        """Report the given error."""
        print( "{}: {}: {} ({})".format( short( module ), error, name, lineno ) )

    # If we found one...
    if doc_string:
        # If it has more than one line...
        if line_count( doc_string ) > 1:
            # ...check it ends with an empty line. Note that we add a space
            # to the end to ensure that any trailing EOL results in an entry
            # at the end of the list.
            if ( doc_string + " " ).splitlines()[ -1 ].strip():
                # Doesn't look good. Report it.
                report( "Bad doc string ending" )
    else:
        report( "Missing doc string" )

##############################################################################
# Report that we're ignoring something.
def ignoring( args, thing, reason ):
    """Report an ignored source.

    :param args: The arguments pulled from the command line.
    :param str thing: The thing we're ignoring.
    :param str reason: The reason we're ignoring it.
    """
    if not args.quiet_ignores:
        print( "{}: {}, ignoring.".format( thing, reason ) )

##############################################################################
# Check the doc strings of a given file.
def check( args, file ):
    """Check the doc strings in the given file.

    :param args: The arguments pulled from the command line.
    :param PosixPath file: The name of the file to check.
    """

    try:

        # Load and parse the file.
        module = ast.parse( file.open( "rb" ).read() )

        # Check the module itself.
        check_doc_string( file, module )

        # For each thing in the module that can have a doc string...
        for node in module_docable_parts( module.body ):
            # ...check its doc string.
            check_doc_string( file, node )

    except SyntaxError:
        ignoring( args, file, "Syntax error" )

##############################################################################
# Does it look like the given file is hidden somehow?
def is_hidden( candidate ):
    """Does the given file look hidden in some way?

    :param PosixPath candidate: The candidate file.
    :returns: A flag to say if the file looks hidden.
    :rtype: bool
    """
    return any( parent.name.startswith( "." ) for parent in candidate.parents )

##############################################################################
# Does the given file look like it's a shebang Python script?
def shebang_python( candidate ):
    """Does a given file look like a Python shebang file?

    :param PosixPath candidate: The candidate file.
    :returns: A flag to say if the file looks like it might be Python code.
    :rtype: bool
    """

    try:
        with candidate.open( "rb" ) as source:
            first_line = source.readline()
            return first_line[ :2 ] == b"#!" and b"python" in first_line
    except IOError:
        return False

##############################################################################
# Does the candidate look like a Python file?
def is_python( candidate ):
    """Does a given file look like it might be Python source?

    :param PosixPath candidate: The candidate file.
    :returns: A flag to say if the file looks like it might be Python code.
    :rtype: bool
    """
    return (
        # Is it a .py file?
        candidate.suffix.lower() == ".py" or
        # ...or perhaps a suffixless file with a Python shebang?
        ( candidate.suffix == "" and shebang_python( candidate ) )
    )

##############################################################################
# Should we check a file?
def should_check( candidate ):
    """Should we check the given file?

    :param PosixPath candidate: The candidate file.
    :returns: A flag to say if we should check the file or not.
    :rtype: bool

    A file should be check if it isn't hidden and it looks like it's Python
    source.
    """
    return ( not is_hidden( candidate ) ) and is_python( candidate )

##############################################################################
# Perform a recursive check over Python files.
def recursive_check( args, to_check ):
    """Perform a recursive check of Python files.

    :param Namespace args: The command line arguments.
    :param PosixPath to_check: The path to check.
    """

    # Let's walk the while tree from the given location.
    for root, _, files in os.walk( str( to_check ) ):

        # For each file we've been given...
        for file in files:

            # Create the fill candidate path.
            candidate = Path( root ).resolve() / file

            # If we should look at the candidate...
            if should_check( candidate ):
                # ...check it.
                check( args, candidate )

##############################################################################
# Get the command line params.
def get_args():
    """Parse the command line parameters.

    :returns: The parsed command line arguments.
    """

    # Create the argument parser object.
    parser = argparse.ArgumentParser(
        description = "Python doc string checker",
        epilog      = "v{}".format( __version__ )
    )

    # Add --quiet-ignores
    parser.add_argument(
        "-q", "--quiet-ignores",
        help   = "Don't report ignored files.",
        action = "store_true"
    )

    # Add --version
    parser.add_argument(
        "-v", "--version",
        help    = "Show version information.",
        action  = "version",
        version = "%(prog)s v{}".format( __version__ )
    )

    # The remainder is the paths/files to check.
    parser.add_argument(
        "to_check",
        nargs = argparse.REMAINDER,
        help  = "Files and directories to check"
    )

    # Parse the command line.
    return parser.parse_args()

##############################################################################
# Main code.
def main():
    """Main entry point."""

    # Get the arguments.
    args = get_args()

    # For each file/directory we've been asked to check...
    for to_check in [ Path( path ).resolve() for path in args.to_check or [ "." ] ]:
        # If it's simply a file...
        if to_check.is_file():
            # ...simply check it.
            check( args, to_check )
        elif to_check.is_dir():
            # It's a directory, let's go recursive...
            recursive_check( args, to_check )
        else:
            # Not a file or directory!
            ignoring( args, to_check, "Not a file or directory" )

##############################################################################
# Main entry point.
if __name__ == "__main__":
    main()

### pydscheck ends here
