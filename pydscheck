#!/usr/bin/env python3
"""Tool to perform simple Python doc string tests."""

##############################################################################
# Module information.
__author__     = "Dave Pearson"
__copyright__  = "Copyright 2018-2019, Dave Pearson"
__licence__    = "GPL"
__credits__    = [ "Dave Pearson" ]
__maintainer__ = "Dave Pearson"
__email__      = "davep@davep.org"
__version__    = "1.1.0"

##############################################################################
# The list of directories that we'll normally not dive in to.
IGNORABLE_DIRS = [ ".git", ".venv" ]

##############################################################################
# Imports.
import os
import ast
import sys
import argparse
from   pathlib import Path

##############################################################################
# Get the short name of a path.
def short( path ):
    """Get a short name for the path that makes sense.

    :param PosixPath path: The path to get a short name for.
    :returns: As short a name as possible for the given path.
    :rtype: str
    """
    try:
        return path.relative_to( Path().cwd() )
    except ValueError:
        return str( path )

##############################################################################
# Get all of the doc-able nodes in the given module.
def module_docable_parts( module ):
    """Get nodes that can have doc strings.

    :param Module module: The module to pull nodes from.
    :yields: An item whose doc string should be checked.
    """
    for node in module:
        for item in ast.walk( node ):
            if isinstance( item, ( ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef ) ):
                yield item

##############################################################################
# Get the line count of a doc string.
def line_count( doc_string ):
    """Get the line count of a doc string.

    :param str doc_string: The doc string to get the line count for.
    :returns: The number of lines found in the doc string.
    :rtype: int
    """
    return len( doc_string.splitlines() )

##############################################################################
# Check the doc string of the given node
def check_doc_string( module, node ):
    """Check the doc string of the given node.

    :param PosixPath module: The path of the module we're checking.
    :param AST node: The ast node to check.
    :returns: A flag to say if the doc string looked okay.
    :rtype: bool
    """

    # Assume we're all okay.
    okay = True

    # Work out what name to show.
    try:
        name = node.name
    except AttributeError:
        name = module.name

    # Work out the line number.
    try:
        lineno = node.lineno
    except AttributeError:
        lineno = 0

    # Extract the doc string for the given node.
    doc_string = ast.get_docstring( node, clean=False )

    def report( error ):
        """Report the given error."""
        print( "{}: {}: {} ({})".format( short( module ), error, name, lineno ) )
        return False

    # If we found one...
    if doc_string:
        # If it has more than one line...
        if line_count( doc_string ) > 1:
            # ...check it ends with an empty line. Note that we add a space
            # to the end to ensure that any trailing EOL results in an entry
            # at the end of the list.
            if ( doc_string + " " ).splitlines()[ -1 ].strip():
                # Doesn't look good. Report it.
                okay = report( "Bad doc string ending" )
    else:
        okay = report( "Missing doc string" )

    # Return what we found.
    return okay

##############################################################################
# Report that we're ignoring something.
def ignoring( args, thing, reason ):
    """Report an ignored source.

    :param Namespace args: The command line arguments.
    :param str thing: The thing we're ignoring.
    :param str reason: The reason we're ignoring it.
    """
    if not args.quiet_ignores:
        print( "{}: {}, ignoring.".format( thing, reason ) )

##############################################################################
# Produce verbose output.
def verbose( args, feedback ):
    """Print output if we're in verbose mode.

    :param Namespace args: The command line arguments.
    :param str feedback: The feedback to print
    """
    if args.verbose:
        print( feedback, file=sys.stderr )

##############################################################################
# Check the doc strings of a given file.
def check( args, file ):
    """Check the doc strings in the given file.

    :param Namespace args: The command line arguments.
    :param PosixPath file: The name of the file to check.
    :returns: A flag to say if the file looked okay.
    :rtype: bool
    """

    # Set out assuming everything's okay.
    okay = True

    # Feedback on what we're checking.
    verbose( args, "Checking {}".format( short( file ) ) )

    try:

        # Load and parse the file.
        module = ast.parse( file.open( "rb" ).read() )

        # Check the module itself.
        check_doc_string( file, module )

        # For each thing in the module that can have a doc string...
        for node in module_docable_parts( module.body ):
            # ...check its doc string.
            if not check_doc_string( file, node ):
                okay = False

    except SyntaxError:
        ignoring( args, file, "Syntax error" )

    # Return what we thought of the file.
    return okay

##############################################################################
# Does it look like the given file is hidden somehow?
def is_hidden( candidate ):
    """Does the given file look hidden in some way?

    :param PosixPath candidate: The candidate file.
    :returns: A flag to say if the file looks hidden.
    :rtype: bool
    """
    return any( parent.name.startswith( "." ) for parent in candidate.parents )

##############################################################################
# Does the given file look like it's a shebang Python script?
def shebang_python( candidate ):
    """Does a given file look like a Python shebang file?

    :param PosixPath candidate: The candidate file.
    :returns: A flag to say if the file looks like it might be Python code.
    :rtype: bool
    """
    try:
        with candidate.open( "rb" ) as source:
            first_line = source.readline()
            return first_line[ :2 ] == b"#!" and b"python" in first_line
    except IOError:
        return False

##############################################################################
# Does the candidate look like a Python file?
def is_python( candidate ):
    """Does a given file look like it might be Python source?

    :param PosixPath candidate: The candidate file.
    :returns: A flag to say if the file looks like it might be Python code.
    :rtype: bool
    """
    return (
        # Is it a .py file?
        candidate.suffix.lower() == ".py" or
        # ...or perhaps a suffixless file with a Python shebang?
        ( candidate.suffix == "" and shebang_python( candidate ) )
    )

##############################################################################
# Should we check a file?
def should_check( candidate ):
    """Should we check the given file?

    :param PosixPath candidate: The candidate file.
    :returns: A flag to say if we should check the file or not.
    :rtype: bool

    A file should be check if it isn't hidden and it looks like it's Python
    source.
    """
    return ( not is_hidden( candidate ) ) and is_python( candidate )

##############################################################################
# Remove ignorable directories.
def remove_ignorable_dirs( args, dirs ):
    """Remove ignorable directories from the given list.

    :param list dirs: The list of directories to be looked at.
    """
    for ignorable in IGNORABLE_DIRS + ( args.ignore or [] ):
        try:
            dirs.remove( ignorable )
            verbose( args, "Skipping content of {}".format( ignorable ) )
        except ValueError:
            pass

##############################################################################
# Perform a recursive check over Python files.
def recursive_check( args, to_check ):
    """Perform a recursive check of Python files.

    :param Namespace args: The command line arguments.
    :param PosixPath to_check: The path to check.
    :returns: A flag to say if any issues were found.
    :rtype: bool
    """

    # Assume everything's okay.
    okay = True

    # Let's walk the while tree from the given location.
    for root, dirs, files in os.walk( str( to_check ) ):

        # Remove directories we should ignore.
        remove_ignorable_dirs( args, dirs )

        # For each file we've been given...
        for file in files:

            # Create the fill candidate path.
            candidate = Path( root ).resolve() / file

            # If we should look at the candidate...
            if should_check( candidate ):
                # ...check it.
                if not check( args, candidate ):
                    okay = False
            else:
                verbose( args, "Skipping {}".format( short( candidate ) ) )

    # Report if any issues where found.
    return okay

##############################################################################
# Get the command line params.
def get_args():
    """Parse the command line parameters.

    :returns: The parsed command line arguments.
    :rtype: Namespace
    """

    # Create the argument parser object.
    parser = argparse.ArgumentParser(
        description = "Python doc string checker",
        epilog      = "v{}".format( __version__ )
    )

    # Add --ignore
    parser.add_argument(
        "-i", "--ignore",
        help   = "Ignore any directory that matches the name.",
        action = "append"
    )

    # Add --quiet-ignores
    parser.add_argument(
        "-q", "--quiet-ignores",
        help   = "Don't report ignored files.",
        action = "store_true"
    )

    # Add --verbose
    parser.add_argument(
        "-v", "--verbose",
        help    = "Be verbose (output what is going on).",
        action  = "store_true"
    )

    # Add --version
    parser.add_argument(
        "-V", "--version",
        help    = "Show version information.",
        action  = "version",
        version = "%(prog)s v{}".format( __version__ )
    )

    # The remainder is the paths/files to check.
    parser.add_argument(
        "to_check",
        nargs = argparse.REMAINDER,
        help  = "Files and directories to check"
    )

    # Parse the command line.
    return parser.parse_args()

##############################################################################
# Main code.
def main():
    """Main entry point.

    :returns: A flag to say if any problems were found.
    :rtype: bool
    """

    # Get the arguments.
    args = get_args()

    # Assume everything is okay.
    okay = True

    # For each file/directory we've been asked to check...
    for to_check in [ Path( path ).resolve() for path in args.to_check or [ "." ] ]:
        # If it's simply a file...
        if to_check.is_file():
            # ...simply check it.
            if not check( args, to_check ):
                okay = False
        elif to_check.is_dir():
            # It's a directory, let's go recursive...
            if not recursive_check( args, to_check ):
                okay = False
        else:
            # Not a file or directory!
            ignoring( args, to_check, "Not a file or directory" )

    # Report on what was found.
    return okay

##############################################################################
# Main entry point.
if __name__ == "__main__":
    sys.exit( 0 if main() else 1 )

### pydscheck ends here
